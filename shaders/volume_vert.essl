#ifndef GL_ES
#version 330 es
#endif

out vec3 vOrigin;
out vec3 vDirection;

void main() {
  vOrigin = vec3(inverse(modelMatrix) * vec4(cameraPosition, 1.0)).xyz;
  vDirection = position - vOrigin;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}


// vec3 entryPoint = vOrigin + rayDir * intersection.x;
// vec3 exitPoint = vOrigin + rayDir * intersection.y;
// vec3 dimensions = vec3(textureSize(dataTexture, 0));
// vec3 entryToExit = exitPoint - entryPoint;
// float samples = ceil(samplingRate * length(entryToExit * (dimensions - vec3(1.0))));
// float tEnd = length(entryToExit);
// float tIncr = tEnd / samples;
// float tStart = 0.5 * tIncr;
// vec3 texEntry = (entryPoint - aabbmin) / (aabbmax - aabbmin);


// vec3 texSize = vec3(textureSize(volumeTexture, 0));
// float boxDist = length(boxSize * texSize);
// float sampleCount = 25.0;
// float rayStep = boxDist / sampleCount;
// float rayIntersectStart = 0.0;
// float rayIntersectEnd = boxDist;
// vec3 texEntry = (pBoxEntry - boxMin) / (boxMax - boxMin);
//
// float density = 0.0;
// for (float i = 0.0; i < sampleCount; i += rayStep) {
//   float rayDistance = boxStart + i;
//   vec3 samplePoint = entryPoint + direction * rayDistance;
//   float value = sampleData(samplePoint);
//   density = max(density, value);
//
//   if (density >= 1.0 || rayDistance > boxEnd) {
//     // Early return if max found or out if box
//     break;
//   }
// }
//
// vec4 color = offColor;
// //if (density >= densityThreshold.x && density <= densityThreshold.y) {
// if (density >= 0.0 && density <= 0.99) {
//   vec4 densityColor = sampleColor(density);
//   color.rgb = densityColor.rgb;
//   color.a = densityColor.a * density;
// }