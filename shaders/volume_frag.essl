#ifndef GL_ES
#version 330 es
#endif

precision highp sampler3D;
precision highp float;

const int COLOR_MAX_COUNT = 10;

uniform sampler3D volumeTexture;
uniform float stepSize;
uniform vec3 size;


// ================
// TODO: UI binding, all of these should be uniforms

// TODO: Convert this to a uniform based on the UI:
// Sets the min and max density to display.
vec2 densityThreshold = vec2(0.33, 0.67);

// TODO: Pass from UI, note that we can have at max COLOR_MAX_COUNT different color steps:
// Marks the thresholds for each color. Must be ordered in ascending
// order. One position (0...1) corresponds to one color (r,g,b,a).
float colorDefinitionPositions[COLOR_MAX_COUNT];
vec4 colorDefinitionColors[COLOR_MAX_COUNT];

// TODO: If we want, we could set this in the UI as well
// The "background" color
vec4 offColor = vec4(0.5);
// ================


in vec3 vOrigin;
in vec3 vDirection;
in vec3 vCameraPosition;

out vec4 frag_color;


void temp_createColorArray() {
  // TODO: Remove once UI binding is implemented
  for (int i = 0; i < COLOR_MAX_COUNT; i++) {
    float step = float(i) / float(COLOR_MAX_COUNT);
    colorDefinitionPositions[i] = step;
    colorDefinitionColors[i] = vec4(step, step / 2.0, 1.0 - step, 1.0);
  }
}


float sampleData(vec3 coord) {
  return texture(volumeTexture, coord).x;
}

vec4 sampleColor(float density) {
  // Note: Color steps must be ordered 0->1 in
  // order for this to sample the correct color!
  for (int i = COLOR_MAX_COUNT - 1; i >= 0; i--) {
    if (density >= colorDefinitionPositions[i]) {
      return colorDefinitionColors[i];
    }
  }
  return offColor;
}

// Intersection of a ray and an axis-aligned bounding box.
// Returns the intersections as the minimum and maximum distance along the ray direction.
vec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {
  vec3 tMin = (boxMin - rayOrigin) / rayDir;
  vec3 tMax = (boxMax - rayOrigin) / rayDir;
  vec3 t1 = min(tMin, tMax);
  vec3 t2 = max(tMin, tMax);
  float tNear = max(max(t1.x, t1.y), t1.z);
  float tFar = min(min(t2.x, t2.y), t2.z);
  return vec2(tNear, tFar);
}

vec4 sampleAlongRay(vec3 entryPoint, vec3 direction, float rayStep, float boxStart, float boxEnd, float sampleCount) {

  // Loop through all samples along the ray, sample the density using max intensity projection.
  float density = 0.0;
  for (float i = 0.0; i < sampleCount; i += 1.0) {
    float rayDistance = boxStart + rayStep * i;
    vec3 samplePoint = entryPoint + direction * rayDistance;
    float value = sampleData(samplePoint);
    density = max(density, value);

    if (density >= 1.0 || rayDistance > boxEnd) {
      // Early return if max found or out if box
      break;
    }
  }

  vec4 color = offColor;
  if (density >= densityThreshold.x && density <= densityThreshold.y) {
    vec4 densityColor = sampleColor(density);
    color.rgb = densityColor.rgb;
    color.a = densityColor.a * density;
  }

  return color;
}

void main() {
  temp_createColorArray();

  // Intersection ray and box
  vec3 direction = normalize(vDirection); // Direction of ray
  vec3 minAABB = -0.5 * size;
  vec3 maxAABB =  0.5 * size;
  vec2 intersection = intersectAABB(vOrigin, direction, minAABB, maxAABB);

  // If near distance <= far distance -> intersection valid
  vec4 color = offColor;
  if (intersection.x <= intersection.y) {
    // Clamp near intersection distance to camera clipping plane
    intersection.x = max(intersection.x, 0.0);

    // Compute ray entry and exit points
    vec3 entryPoint = vOrigin + direction * intersection.x;
    vec3 exitPoint = vOrigin + direction * intersection.y;

    // Calculate sampling rate and step size
    vec3 texSize = vec3(textureSize(volumeTexture, 0));
    vec3 boxSize = exitPoint - entryPoint;
    float rayDistanceTexSpace = length(boxSize * (texSize - vec3(1.0))); // Distance to traverse through the box in texture space
    float sampleCount = ceil(stepSize * rayDistanceTexSpace);
    float boxEnd = length(boxSize);
    float rayStep = boxEnd / sampleCount;
    float boxStart = 0.5 * rayStep;

    vec3 entryPointTexSpace = (entryPoint - minAABB) / (maxAABB - minAABB); // Normalize box size to texture space
    color = sampleAlongRay(entryPointTexSpace, direction, rayStep, boxStart, boxEnd, sampleCount);
  }

  frag_color = color;
}

